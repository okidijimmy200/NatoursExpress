Modelling Data and Advanced Mongoose
Lecture 1:
Modelling Data in monogbd
-one of the most important steps in building data intensive apps
is to model data in mongodb

Data Modelling::
--this is the process of taking unstructured data generated by real world
sceenarios and structure it into a logical data model in a databse


ie if we want to design an online shop data model,
initially there is a tonne of unstructured data ie categories,cart,supplies,customers,orders,products
--here we need to restructure data in a logical way reflecting the realworld relationships
products<-->suppliers
  ^
  |         ^
  |          |
  orders <-->cart

  -as a backend eng, this is the place you have to think the most
  bse its not straight forward

  Steps of data Modelling
  --Different types of relationships between data
  --Referencing/Normalization vs embedding/denormalization
  -framework for deciding whether to embedd documents or reference to other documents
  --types of referencing

  --the way we design our data can make or break our application

 A) TYPES OF RELATIONSHIPS BETWEEN DATA
  1:1
-here only one field can only have one value ie
 one movie ------> has one name(movie ---> name)
***not very important in data modeling

  1:MANY
  -very important in data Modelling
-in mongodb, we identify 3 types of one to MANY

1:FEW
ie one movie can win many awards bt jst a few like 3 or 4 not 1000 awards

1:MANY
1 document can reate to hundreds or thousands of documents
ie 1 movie can have 1000 reviews

1:TON(million)
ie logging functionality in our app
--these logs can grow to millions in our documents 
--here the app can grow to almost infinity

MANY:MANY
--here one movie can have mulitple actors bt at the sametime one actor can play
in many movies
-the relationships goes in both directions 

B)
REFERENCING VS EMBEDDING
--if we have 2 related datasets, we can represent it in a referenced/normalized form
or embedd or denormalized form

referenced form:
-we keep the 2 related datasets and all the documents separated
ie 1 movie document and 1 actor document for eah actor
--we make connection btn movie and actor using IDs
--this is called child referencing bse its the parent(movie) wch references child(movie)
--SQL databsae, data is done like this

--In NoSQL databse like mongodb, we denormalize data into a denormalized form by embedding the related document
into the main document
--so we have relavant data abt actors in the movie

so here our app will make fewer queries to the database bse we an get data abt movies and actors at the sametime

--the challenge here is tht we cant query the data on its own so we will need a normalized design for this

--advantages of normalized
**improvement in performance

--disadvanatge
**we need many queries in the database if we are to query both mvies and actors at the same time

--how to decide whether we will normalize or denormalize data
(combine the 3 criteria when deciding)
&&&&--first look at the type of relationships
(how 2 databases are related to one another)
&&&&--data access patterns
(How often data is read and written. Read/write ratio)
&&&&--Data closeness
(how much the data is really related)

ie movie with 100 images
                       ***Embedding                                    ***Referencing
Relationship type:    1-FEW, 1:MANY                                     1:MANY, 1:TON, MANY:MANY

Data Access:          data is mostly read                              Data is updated alot
                      data doenst change quickly                        low(read/write ratio)
                      high read/write ratio                              -if data is updated alot, then we reference
                      --movie + images embedded(not updated)             ie updating the reviews 

Data Closenes:      --if data r closely related                       --we frequently need to query data on their own
                    many users can hv many email address on account
                    so emails r embedded to database

C) TYPES OF REFERENCING
-Child referencing                                        parent referencing                         2-way referencing
**references to related child documents                   --each child doc, we keep                 ---each movie has many actors and many actors and each actor plays in many movies           
r kept in a parent document in an array                   a ref to parent ref                       ---here we keep ref to each actor tht stars in a movie like child referencing & each actor
--challenge is id can grow big wch is bad                 --its more effective thn child              we keep a ref of the movie the actor played in so connected in both directions
--parents nd children r tytly coupled(chld referencing)   --bst used for one to many relationships
--child relationships is used for one to few relationships & one to aton
where array of docs wont grow tht much

--In mongodb, an array shd not be allowed to grow indefinately abovee the 16MB limit
--dont send user 1000 of IDS


Summary:
---strucutre your data to much the ways ur application queries and updates data
--always favour embedding unless otherwise
--1:TON favor referencing instead of embedding
--dont allow arrays to grow indefinately
--use 2-way referencing for MANY:MANY relationships

Lecture 2:
DESIGNING OUR DATA:
--use theory to design the data model of our natours app

THE NATOURS DATA MODEL:::(datasets)
tours
---relationship btn tours and reviews
**1:MANY relationship whereone tour can have mulitple reviews bt one review cqn only be to one tour
**parent referencing here so the reviews end up with tour and user ids

---relationship btn tours and locations
**FEW:FEW where each tour can have different locations 
**each location might also be used in the different tours
**Embedding
--we can implement 2-way referencing(normalizing the locations into its own datasets)
--bt here we will denormalie the ref to tours bse they are related

--relationship btn tour and user:
**this is bse we have tour guides who will be users
**this is a FEW:FEW relationship
**2-ways referencing
users
--relationship btn users and reviews
**one-to-many relationship bse one user can write mulitple reviewa
bt one review can only belong to one user(parent:users, child:reviews)
-we use parent referencing here

reviews



locations


bookings

--there is a relationship btn tours and booking and also users and booking
**one tour can have mulitple bookings bt one booking can only belong to one tour
--same thing with users
--we use parent referencing

Lecture 3:
Modelling locations and Advanced:
--geospatial data in mongodb
--everything related to locations will be in our tours model
--geospatial data r places on earth described using longitude and latitiude co-ordinates
---we can describe lines, polygons, with geospatial data

--import tour.json data

Lecture 4:
Modelling Tour Guides Embedding:
--embedd user docs in tour docs


Lecture 5:
Modelling Tour Guides Child Referencing
--lets connect tours to users using referencing
--here users and tours will be separate entities in our database
-this will contain only the ids of the tour guides and not the actual users

Lecture 6:
Populating tour guides:
--using populate to get access to the referenced tour guides when we query for certain tour
--this makes the data look as if its bn embedded yet we have jst populated it
-this happens in tourzController
-this displays to us information bt doesnot create them in the database
--we can create an object of options in populate
--populate may affect your performance so its best not used alot 

Lecture 7:
Modelling Reviews Parent Referencing:
-implementing the reviews model
-we create a new filein the models called reviews.js

Lecture 8:
Creating and Getting Reviews:
--we will implement an endpoint for getting reviews and also creating new reviews
--creating endpoint for getting reviews and also creating new reviews

Lecture 9:
Populate Reviews:
--populate reviews with tour and user data
--these will be automatically populated when there is a query for review
--to populate 2 fields,u call the populate twice

Lecture 10:
Virtual Populate Tours and Reviews
--virtual populate helps us access reviews the other way round ie 
getting reviews from tours bse the parent doesnot knw abt its siblings
--here the parent(tour) doesnot knw abt reviews
-virtual populate helps us populate tours with reviews

--the challenge with this is tht it creates a chain of reviews
--reviews get populated wih tour and user and the tour gets  populated by the guides

-we will turn off populate for reviews with tours

Lecture 11:
Implementing Simple Nested Routes:
--how to create new review in the real world
--the user id shd come from logged in user and tour id shd come from current tour
--this shd be encodded in the URL

--this is a much easier way of reading APIs for API users
--its easier thn query strings
--we will implement this in the tour router

Lecture 12:
Nested Routes with Express:
--we will use an advanced express feature
--the last vid we implemented simple nested  post route
--this is a common way to do this in API design
--the problem with this is its abit messy with duplicate code

--how do we mount the review router in the tour router
--by default each router has access to only params of their route
--with merger params, we can have access to tour id from reviewRouter

Lecture 13:
Ading a Nested GET Endpoint
--creating a nested end point
we create a nested end point for the get tour section

Lecture 14:
building handler factory functions delete
--how to build a handler factory function in order to delete review documents
-this is used to remove duplicate code
--a factory function is a function tht returns another function wch is our handler function
used for deleting, creating, updating

Lecture 15:
Factory Functions Update and Create
--creating factory function for updatin and creating resources

Lecture 16:
Factory FUnctions Reading:
--creating factories for getting document
--we will start with getOne
--the challenge with the getOne in tour is tht it has a populate function
--we use an option in the factory function to handle this situation

--we then do get all factory function

Lecture 17:
Adding a me EndPoint:
--its a gd practice to add a /me endpoint in our API
--where a user can retrieve his own data

Lecture 18:
Adding Missing Authentication and Authentication:
--we need to fix some Authentication and authorization in our resources.
--this is usually defined on the Routes
--the tour API is what we want to interact ith the outside world
ie we want our tour company to interact with other travel sites.
--so how do we make sure it embedds it in their website
--so no authorization on getAll tours route

--to edit and delete actions of tours, we want the lead guides to be ble to do this
--the protect function on the routes runs as a middleware wch always runs in sequence

--we then protect the reviews where we dont allow anyonw who is not logged in to delete reviews


Lecture 19:
Importing Review and User Data:
--importing data on reviews and users from the data
--we update dev-data import script

**********node ./dev-data/data/import-dev-data.js --delete****************
to delete data in the database

**********node ./dev-data/data/import-dev-data.js --import****************
import data
--we need to turn off vallidation for password at the import dev data
--we also turn off password encryption to imprt the files

Lecture 20:
Improving Read Performance with indexes
--importance of index and how to generate them
-we can get a couple of statics abt the query itself
--we use the explain method in getAll query in factory wch gives examines 9 documents
this is not efficient at all bse it affects the read performance esp with big applications
--this can best be solved using indexes
--we cn create indexes on specific fields on a collection
--ie monogd automatically creates index for ID

--in mongod compass, we do have an index array
--so whenever monoodb are queried by ID, monogodb will search tht ordered list instead of searching the whole collection and
look at the docs one by one
--the process thn becomes very efficient
--we perform query for fields tht we query very often ie price

Lecture 21:
Calculating Average Ratings on Tour Part 1:
--we can store the average ratings and the number of ratings on each tour so tht we dont need to calculate the average each time we 
query for all the tours
-ie if we want to show a summary of reviews for our tour
--we will calc avg rating an number of ratings of a tour each time a new review is added to tht tour or incase a review is updated or deleted.
--we will create a fn in review wch will take in a tourID and calculate the average ratings and the number of ratings tht exist in tht
tour collection
--the function thn updates the corresponding tour document
--we thn use tht function we will use middleware to basically call this function each time there is a new review or one is updated or deleted

--so when we create a review from tour,it shows us the review on the console minus the latest review jst send
--this then calculates the average ratings

Lecture 22:
Calculating Average Ratings on Tour Part 2:
--when a review is updated or deleted.




--we query the tourModel index
--wen we getAll query in postman, we see tht 3 docs were examined and
--we can give unique to indexes
--the name fields attr is also included bse we set the name field to be unique
--this is a single field index
{{URL}}api/v1/tours?price[lt]=1000

--we also have  a compund field index
{{URL}}api/v1/tours?price[lt]=1000&ratingsAverage[gt]=4

--how do we decide wchh fields to index:
--we study the access path of our prog and determine wch systems are queried the most
